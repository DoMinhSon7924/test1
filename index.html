<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Lang Hạnh Trương ngố bel</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
  <style>
    body { margin: 0; overflow: hidden; background-color: #000000; font-family: 'Segoe UI', sans-serif; }
    #canvas-container { width: 100%; height: 100vh; display: block; }
    #camera-preview {
      position: absolute; top: 15px; right: 15px;
      width: 120px; height: 90px;
      border: 2px solid rgba(255,105,180,0.6);
      transform: scaleX(-1);
      opacity: 0.9; border-radius: 8px;
      background: #000;
    }
    #error-log { display: none; position: absolute; top: 0; left: 0; color: red; background: rgba(0,0,0,0.8); z-index: 999; padding: 10px; }
  </style>
</head>
<body>
  <div id="error-log"></div>
  <div id="canvas-container"></div>
  <video class="input_video" style="display:none"></video>
  <canvas id="camera-preview"></canvas>
  <script>
    const loader = new THREE.TextureLoader();
    const PNG = ['./1.PNG', './2.PNG', './3.PNG', '.4.PNG', '.5.PNG'];
    const photoTextures = [];
    PNG.forEach((f, i) => photoTextures[i] = loader.load(f));
    function makeCanvasTex(drawFn, size=512) {
      const canvas = document.createElement('canvas');
      canvas.width = size; canvas.height = size;
      const ctx = canvas.getContext('2d');
      drawFn(ctx, size);
      const tex = new THREE.CanvasTexture(canvas);
      tex.minFilter = THREE.LinearFilter;
      tex.magFilter = THREE.LinearFilter;
      tex.generateMipmaps = true;
      tex.needsUpdate = true;
      return tex;
    }
    function createCustomTexture(type) {
      const cx = 0.5, cy = 0.5;
      if (type === 'pink_glow') {
        return makeCanvasTex((ctx, s) => {
          const g = ctx.createRadialGradient(s*cx, s*cy, 0, s*cx, s*cy, s*0.42);
          g.addColorStop(0.00, 'rgba(255,255,255,1)');
          g.addColorStop(0.18, 'rgba(255,209,234,1)');
          g.addColorStop(0.55, 'rgba(255,105,180,0.95)');
          g.addColorStop(1.00, 'rgba(0,0,0,0)');
          ctx.fillStyle = g; ctx.fillRect(0,0,s,s);
        }, 512);
      } else if (type === 'hot_pink_light') {
        return makeCanvasTex((ctx, s) => {
          const g = ctx.createRadialGradient(s*cx, s*cy, 0, s*cx, s*cy, s*0.50);
          g.addColorStop(0.00, 'rgba(255,230,243,1)');
          g.addColorStop(0.30, 'rgba(255,20,147,0.95)');
          g.addColorStop(1.00, 'rgba(0,0,0,0)');
          ctx.fillStyle = g; ctx.fillRect(0,0,s,s);
        }, 512);
      } else if (type === 'snow_glow') {
        return makeCanvasTex((ctx, s) => {
          const g = ctx.createRadialGradient(s*cx, s*cy, 0, s*cx, s*cy, s*0.40);
          g.addColorStop(0.00, 'rgba(255,255,255,1)');
          g.addColorStop(0.22, 'rgba(255,255,255,0.95)');
          g.addColorStop(0.55, 'rgba(255,255,255,0.35)');
          g.addColorStop(1.00, 'rgba(0,0,0,0)');
          ctx.fillStyle = g; ctx.fillRect(0,0,s,s);
        }, 512);
      } else if (type === 'ground_glow') {
        return makeCanvasTex((ctx, s) => {
          const g = ctx.createRadialGradient(s*cx, s*cy, 0, s*cx, s*cy, s*0.45);
          g.addColorStop(0.00, 'rgba(255,255,255,0.9)');
          g.addColorStop(0.15, 'rgba(255,209,234,0.85)');
          g.addColorStop(0.45, 'rgba(255,105,180,0.55)');
          g.addColorStop(1.00, 'rgba(0,0,0,0)');
          ctx.fillStyle = g; ctx.fillRect(0,0,s,s);
        }, 512);
      } else if (type === 'white_spiral') {
        return makeCanvasTex((ctx, s) => {
          const g = ctx.createRadialGradient(s*cx, s*cy, 0, s*cx, s*cy, s*0.42);
          g.addColorStop(0.00, 'rgba(255,255,255,1)');
          g.addColorStop(0.20, 'rgba(255,255,255,0.95)');
          g.addColorStop(0.55, 'rgba(255,255,255,0.35)');
          g.addColorStop(1.00, 'rgba(0,0,0,0)');
          ctx.fillStyle = g; ctx.fillRect(0,0,s,s);
        }, 512);
      } else if (type === 'heart_glow') {
        return makeCanvasTex((ctx, s) => {
          ctx.clearRect(0,0,s,s);
          const g1 = ctx.createRadialGradient(s*cx, s*cy, 0, s*cx, s*cy, s*0.20);
          g1.addColorStop(0.0, 'rgba(255,255,255,1)');
          g1.addColorStop(1.0, 'rgba(255,255,255,0)');
          ctx.fillStyle = g1; ctx.fillRect(0,0,s,s);
          const g2 = ctx.createRadialGradient(s*cx, s*cy, s*0.06, s*cx, s*cy, s*0.44);
          g2.addColorStop(0.00, 'rgba(255,230,245,0.95)');
          g2.addColorStop(0.22, 'rgba(255,150,210,0.90)');
          g2.addColorStop(0.58, 'rgba(255,20,147,0.55)');
          g2.addColorStop(1.00, 'rgba(0,0,0,0)');
          ctx.fillStyle = g2; ctx.fillRect(0,0,s,s);
          const g3 = ctx.createRadialGradient(s*cx, s*cy, s*0.22, s*cx, s*cy, s*0.70);
          g3.addColorStop(0.0, 'rgba(255,105,180,0.22)');
          g3.addColorStop(1.0, 'rgba(0,0,0,0)');
          ctx.fillStyle = g3; ctx.fillRect(0,0,s,s);
        }, 512);
} else if (type === 'gift_pink') {
  return makeCanvasTex((ctx, s) => {
    const pad = Math.floor(s * 0.16);
    const box = s - pad * 2;
    ctx.clearRect(0, 0, s, s);
    ctx.fillStyle = '#FFFFFF';
    ctx.fillRect(pad, pad, box, box);
    ctx.fillStyle = '#FF69B4';
    const ribbon = Math.max(6, Math.floor(s * 0.06));
    ctx.fillRect(
      pad + Math.floor(box * 0.5) - Math.floor(ribbon * 0.5),
      pad,
      ribbon,
      box
    );
    ctx.fillRect(
      pad,
      pad + Math.floor(box * 0.5) - Math.floor(ribbon * 0.5),
      box,
      ribbon
    );
    ctx.strokeStyle = 'rgba(0,0,0,0.35)';
    ctx.lineWidth = Math.max(2, Math.floor(s * 0.012));
    ctx.strokeRect(pad, pad, box, box);
  }, 256);
}
      return makeCanvasTex((ctx, s) => {
        ctx.fillStyle = 'rgba(255,255,255,1)';
        ctx.beginPath(); ctx.arc(s*0.5, s*0.5, s*0.2, 0, Math.PI*2); ctx.fill();
      }, 256);
    }
    const textures = {
      gold:  createCustomTexture('pink_glow'),
      red:   createCustomTexture('hot_pink_light'),
      gift:  createCustomTexture('gift_pink'),
      snow:  createCustomTexture('snow_glow'),
      ground:createCustomTexture('ground_glow'),
      heart: createCustomTexture('heart_glow'),
      whiteSpiral: createCustomTexture('white_spiral'),
    };
    
    const CONFIG = {
      goldCount: 2800,
      redCount: 450,
      giftCount: 80,
      explodeRadius: 65,
      photoOrbitRadius: 25,
      treeHeight: 70,
      treeBaseRadius: 35,
      heartStarCount: 1000,
      snowCount: 1200,
      groundCount: 5000,  
      groundRadius: 120,
      groundSpiralTurns: 7.2,
      groundSpiralTightness: 1.0,
      auraCount: 1400,
      auraTurns: 5.5,
      auraRadiusMin: 10.0,
      auraRadiusMax: 30.0,
      auraJitter: 0.65,
    };
    let scene, camera, renderer;
    let groupGold, groupRed, groupGift;
    let photoMeshes = [];
    let titleMesh, loveMesh;
    let heartStarMesh;
    let snowMesh, groundMesh, groundMeshSoft;
    let auraSpiralMesh = null;
    let state = 'TREE';
    let selectedIndex = 0;
    let handX = 0.5;
    let heartGestureFrames = 0;
    let treeFade = 1.0;
    
    function init3D() {
      const container = document.getElementById('canvas-container');
      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x000000, 0.0023);
      camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.z = 100;
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      container.appendChild(renderer.domElement);
      groupGold = createParticleSystem('gold', CONFIG.goldCount, 1.55);
      groupRed  = createParticleSystem('red',  CONFIG.redCount,  2.0);
      groupGift = createParticleSystem('gift', CONFIG.giftCount, 3.0);
      createPhotos();
      createDecorations();
      createHeartStar();
      createSnow();
      createGroundWaves();
      createAuraSpiral();
      animate();
    }

    function createParticleSystem(type, count, size) {
      const pPositions = [];
      const pExplodeTargets = [];
      const pTreeTargets = [];
      const pHeartTargets = [];
      const sizes = [];
      const phases = [];

      for(let i=0; i<count; i++) {
        const h =  CONFIG.treeHeight * (1 - Math.pow(Math.random(), 0.55));
        const y = h - CONFIG.treeHeight / 2;
        let radiusRatio = (type === 'gold') ? Math.sqrt(Math.random()) : 0.9 + Math.random()*0.1;
        const maxR = (1 - (h / CONFIG.treeHeight)) * CONFIG.treeBaseRadius;
        const r = maxR * radiusRatio;
        const theta = Math.random() * Math.PI * 2;
        pTreeTargets.push(r * Math.cos(theta), y, r * Math.sin(theta));
        const u = Math.random();
        const v = Math.random();
        const phi = Math.acos(2 * v - 1);
        const lam = 2 * Math.PI * u;
        let radMult = (type === 'gift') ? 1.2 : 1.0;
        const rad = CONFIG.explodeRadius * Math.cbrt(Math.random()) * radMult;
        pExplodeTargets.push(
          rad * Math.sin(phi) * Math.cos(lam),
          rad * Math.sin(phi) * Math.sin(lam),
          rad * Math.cos(phi)
        );
        const tHeart = Math.random() * Math.PI * 2;
        let hx = 16 * Math.pow(Math.sin(tHeart), 3);
        let hy = 13 * Math.cos(tHeart) - 5 * Math.cos(2*tHeart) - 2 * Math.cos(3*tHeart) - Math.cos(4*tHeart);
        const rFill = Math.pow(Math.random(), 0.3);
        hx *= rFill; hy *= rFill;
        let hz = (Math.random() - 0.5) * 8 * rFill;
        const noise = 0.9;
        hx += (Math.random() - 0.5) * noise;
        hy += (Math.random() - 0.5) * noise;
        hz += (Math.random() - 0.5) * noise;
        const scaleH = 2.2;
        pHeartTargets.push(hx * scaleH, hy * scaleH + 5, hz);
        pPositions.push(
          pTreeTargets[i*3], pTreeTargets[i*3+1], pTreeTargets[i*3+2]
        );
        const jitter = (type === 'gift') ? 0.0 : (Math.random() * 0.22 - 0.11);
        sizes.push(Math.max(0.85, size * 1.15 + jitter));
        phases.push(Math.random() * Math.PI * 2);
      }
      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.Float32BufferAttribute(pPositions, 3));
      geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
      const colors = new Float32Array(count * 3);
      const baseColor = new THREE.Color();
      if (type === 'gold') {
        baseColor.setHex(0xFF6FAE);
      }
      else if (type === 'red') {
        baseColor.setHex(0xFF3F8E); 
      }
      else {
        baseColor.setHex(0xFFD1EA);
      }
      for(let i=0; i<count; i++) {
        colors[i*3] = baseColor.r;
        colors[i*3+1] = baseColor.g;
        colors[i*3+2] = baseColor.b;
      }
      geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      geo.userData = {
        tree: pTreeTargets, explode: pExplodeTargets, heart: pHeartTargets,
        phases: phases, baseColor: baseColor, baseSize: size
      };
      const mat = new THREE.PointsMaterial({
        size: size,
        map: textures[type],
        transparent: true,
        opacity: 1.0,
        vertexColors: true,
        blending: (type === 'gift') ? THREE.NormalBlending : THREE.AdditiveBlending,
        depthWrite: false,
        sizeAttenuation: true,
        alphaTest: (type === 'gift') ? 0.0 : 0.02
      });
      const points = new THREE.Points(geo, mat);
      scene.add(points);
      return points;
    }
    function createPhotos() {
      const geo = new THREE.PlaneGeometry(8, 8);
      const borderGeo = new THREE.PlaneGeometry(9, 9);
      const borderMat = new THREE.MeshBasicMaterial({ color: 0xFF69B4 });
      for(let i=0; i<5; i++) {
        const mat = new THREE.MeshBasicMaterial({ map: photoTextures[i], side: THREE.DoubleSide });
        const mesh = new THREE.Mesh(geo, mat);
        const border = new THREE.Mesh(borderGeo, borderMat);
        border.position.z = -0.1;
        mesh.add(border);
        mesh.visible = false; mesh.scale.set(0,0,0);
        scene.add(mesh);
        photoMeshes.push(mesh);
      }
    }
function createTitleText(text) {
  const canvas = document.createElement('canvas');
  canvas.width = 2048;
  canvas.height = 256;
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  let fontSize = 100;
  const maxWidth = canvas.width * 0.92;
  do {
    ctx.font = `bold italic ${fontSize}px "Times New Roman"`;
    if (ctx.measureText(text).width <= maxWidth) break;
    fontSize--;
  } while (fontSize > 26);
  ctx.fillStyle = '#FF69B4';
  ctx.shadowColor = '#FF1493';
  ctx.shadowBlur = 40;
  ctx.fillText(text, canvas.width / 2, canvas.height / 2);
  const texture = new THREE.CanvasTexture(canvas);
  texture.minFilter = THREE.LinearFilter;
  texture.magFilter = THREE.LinearFilter;
  texture.needsUpdate = true;
  const material = new THREE.MeshBasicMaterial({
    map: texture,
    transparent: true,
    blending: THREE.AdditiveBlending
  });
  const aspect = canvas.width / canvas.height;
  const height = 14;
  const width = height * aspect;

  const mesh = new THREE.Mesh(
    new THREE.PlaneGeometry(width, height),
    material
  );
  return mesh;
}
    function createDecorations() {
      titleMesh = createTitleText("LƯƠNG HẠNH TRANG GIÁNG SINH VUI VẺ");
      titleMesh.position.set(0, 50, 0);
      scene.add(titleMesh);
      const loveCanvas = document.createElement('canvas');
      loveCanvas.width = 2048; loveCanvas.height = 256;
      const lCtx = loveCanvas.getContext('2d');
      lCtx.font = 'bold 120px "Segoe UI", sans-serif';
      lCtx.fillStyle = '#FF69B4';
      lCtx.textAlign = 'center';
      lCtx.shadowColor = "#FF1493";
      lCtx.shadowBlur = 45;
      lCtx.fillText("BÉ NGỐ HẸ HẸ ", 512, 130);
      const loveTex = new THREE.CanvasTexture(loveCanvas);
      loveTex.minFilter = THREE.LinearFilter; loveTex.magFilter = THREE.LinearFilter; loveTex.needsUpdate = true;
      const loveMat = new THREE.MeshBasicMaterial({ map: loveTex, transparent: true, blending: THREE.AdditiveBlending });
      loveMesh = new THREE.Mesh(new THREE.PlaneGeometry(70, 18), loveMat);
      loveMesh.position.set(0, 0, 20);
      loveMesh.visible = false;
      scene.add(loveMesh);
    }
    function createHeartStar() {
      const count = CONFIG.heartStarCount;
      const positions = new Float32Array(count * 3);
      const basePositions = new Float32Array(count * 3);
      const dissolveTargets = new Float32Array(count * 3);
      const phases = new Float32Array(count);
      const ballCenter = new THREE.Vector3(0, CONFIG.treeHeight/2 + 4, 0);
      const ballRadius = 5.2;
      for (let i = 0; i < count; i++) {
      const t = Math.random() * Math.PI * 2;
      let x = 16 * Math.pow(Math.sin(t), 3);
      let y =  13 * Math.cos(t) -  5 * Math.cos(2 * t) -  2 * Math.cos(3 * t) -  Math.cos(4 * t);
      const fill = Math.pow(Math.random(), 0.18);
      x *= fill;
      y *= fill;
      let z = (Math.random() - 0.5) * 6 * fill;
      const fuzz = 1.2;
      x += (Math.random() - 0.5) * fuzz;
      y += (Math.random() - 0.5) * fuzz;
      z += (Math.random() - 0.5) * fuzz;
      const scale = 0.55;
      positions[i*3]   = x * scale;
      positions[i*3+1] = y * scale;
      positions[i*3+2] = z * scale;
      basePositions[i*3]   = positions[i*3];
      basePositions[i*3+1] = positions[i*3+1];
      basePositions[i*3+2] = positions[i*3+2];
      }
      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geo.userData = { basePositions, dissolveTargets, phases, fade: 1.0 };
      const mat = new THREE.PointsMaterial({
        size: 1.55,
        map: textures.heart,
        color: 0xFFFFFF,
        transparent: true,
        opacity: 1.0,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        alphaTest: 0.02
      });
      heartStarMesh = new THREE.Points(geo, mat);
      heartStarMesh.position.set(0, CONFIG.treeHeight/2 + 4, 0);
      scene.add(heartStarMesh);
    }
    function createSnow() {
      const count = CONFIG.snowCount;
      const positions = new Float32Array(count * 3);
      const speeds = new Float32Array(count);
      const phases = new Float32Array(count);
      for (let i = 0; i < count; i++) {
        positions[i*3]   = (Math.random() - 0.5) * 220;
        positions[i*3+1] = Math.random() * 140 - 20;
        positions[i*3+2] = (Math.random() - 0.5) * 220;
        speeds[i] = 0.07 + Math.random() * 0.22;
        phases[i] = Math.random() * Math.PI * 2;
      }
      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geo.userData = { speeds, phases };
      const mat = new THREE.PointsMaterial({
        size: 1.05,
        map: textures.snow,
        color: 0xFFFFFF,
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        alphaTest: 0.02
      });
      snowMesh = new THREE.Points(geo, mat);
      scene.add(snowMesh);
    }
    function createGroundWaves() {
      const count = CONFIG.groundCount;
      const positions = new Float32Array(count * 3);
      const colors = new Float32Array(count * 3);
      const phases = new Float32Array(count);
      const yBase = -CONFIG.treeHeight/2 - 2.5;
      const base = new THREE.Color(0xFFFFFF);
      for (let i = 0; i < count; i++) {
        const u = Math.pow(Math.random(), 0.62);
        const r = u * CONFIG.groundRadius;
        const ringStep = 4.2;
        const ringed = Math.round(r / ringStep) * ringStep;
        const ang = Math.random() * Math.PI * 2;
        let x = Math.cos(ang) * ringed;
        let z = Math.sin(ang) * ringed;
        const jitter = (1 - u) * 1.15 + 0.25;
        x += (Math.random() - 0.5) * jitter * 2.2;
        z += (Math.random() - 0.5) * jitter * 2.2;
        const wave = Math.sin(r * 0.18 + ang * 2.0) * (0.22 + (1-u)*0.18);
        positions[i*3]   = x;
        positions[i*3+1] = yBase + wave + (Math.random() - 0.5) * 0.35;
        positions[i*3+2] = z;
        const bright = 0.38 + (1-u) * 0.45 + Math.random() * 0.12;
        colors[i*3]   = base.r * bright;
        colors[i*3+1] = base.g * bright;
        colors[i*3+2] = base.b * bright;
        phases[i] = Math.random() * Math.PI * 2;
      }
      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      geo.userData = { phases, baseColor: base };
      const mat = new THREE.PointsMaterial({
        size: 1.22,
        map: textures.ground,
        transparent: true,
        opacity: 0.82,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        alphaTest: 0.02
      });
      groundMesh = new THREE.Points(geo, mat);
      scene.add(groundMesh);
      const geo2 = geo.clone();
      const mat2 = new THREE.PointsMaterial({
        size: 2.30,
        map: textures.ground,
        transparent: true,
        opacity: 0.28,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        alphaTest: 0.02
      });
      groundMeshSoft = new THREE.Points(geo2, mat2);
      groundMeshSoft.position.y -= 0.2;
      scene.add(groundMeshSoft);
    }
 function createAuraSpiral() {
  const count = CONFIG.auraCount;
  const positions = new Float32Array(count * 3);
  const colors = new Float32Array(count * 3);
  const phases = new Float32Array(count);
  const base = new THREE.Color(0xFFFFFF);
  const smoothstep = (a, b, x) => {
    const t = Math.min(1, Math.max(0, (x - a) / (b - a)));
    return t * t * (3 - 2 * t);
  };
  const dir = (CONFIG.auraDir !== undefined) ? CONFIG.auraDir : 1;
  const wrapStart = 0.06;
  const wrapFull  = 0.31; 
  for (let i = 0; i < count; i++) {
    const s = i / (count - 1);
    const y = (CONFIG.treeHeight / 2) - s * CONFIG.treeHeight;
    const wrap = smoothstep(wrapStart, wrapFull, s);
    const ang = dir * (s * CONFIG.auraTurns * Math.PI * 2) * (0.12 + 0.88 * wrap);
    const conePow = 1.15;
    const coneR = CONFIG.auraRadiusMin + Math.pow(s, conePow) * (CONFIG.auraRadiusMax - CONFIG.auraRadiusMin);
    const r = coneR * (0.01 + 0.98 * wrap);
    let x = Math.cos(ang) * r;
    let z = Math.sin(ang) * r;
    const orbitPull = 0.45;
    x = x * (1 - orbitPull) + Math.cos(ang) * r * orbitPull;
    z = z * (1 - orbitPull) + Math.sin(ang) * r * orbitPull;
    const jitterFade = (0.15 + 0.85 * wrap) * Math.pow(1 - s, 0.7);
    x += (Math.random() - 0.5) * CONFIG.auraJitter * jitterFade;
    z += (Math.random() - 0.5) * CONFIG.auraJitter * jitterFade;
    const sway = Math.sin(ang * 1.2 + s * 3.0) * 0.22 * wrap * Math.pow(1 - s, 0.6);
    x += Math.cos(ang + 1.1) * sway;
    z += Math.sin(ang + 1.1) * sway;
    positions[i * 3]     = x;
    positions[i * 3 + 1] = y;
    positions[i * 3 + 2] = z;
    const bright = 0.75 + Math.random() * 0.35;
    colors[i * 3]     = base.r * bright;
    colors[i * 3 + 1] = base.g * bright;
    colors[i * 3 + 2] = base.b * bright;
    phases[i] = Math.random() * Math.PI * 2;
  }
  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  geo.userData = { phases, baseColor: base };
  const mat = new THREE.PointsMaterial({
    size: 1.05,
    map: textures.whiteSpiral,
    transparent: true,
    opacity: 1.0,
    vertexColors: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
    alphaTest: 0.02
  });
  auraSpiralMesh = new THREE.Points(geo, mat);
  scene.add(auraSpiralMesh);
}  
    function updateParticleGroup(group, type, targetState, speed, handRotY, time) {
      const positions = group.geometry.attributes.position.array;
      const sizes = group.geometry.attributes.size.array;
      const colors = group.geometry.attributes.color.array;
      const phases = group.geometry.userData.phases;
      const baseColor = group.geometry.userData.baseColor;
      const baseSize = group.geometry.userData.baseSize;
      const targetKey = (targetState === 'TREE') ? 'tree' : (targetState === 'HEART' ? 'heart' : 'explode');
      const targets = group.geometry.userData[(targetState === 'PHOTO') ? 'explode' : targetKey];
      for(let i=0; i<positions.length; i++) {
        positions[i] += (targets[i] - positions[i]) * speed;
      }
      group.geometry.attributes.position.needsUpdate = true;
      const count = positions.length / 3;
      if (targetState === 'TREE') {
        group.rotation.y += 0.003;
        for(let i=0; i<count; i++) {
          sizes[i] = (type === 'gift') ? baseSize : (baseSize * (0.90 + 0.12 * Math.sin(time*2 + phases[i])));
let brightness;
if (type === 'gold') {
  brightness = 0.90 + 0.28 * Math.sin(time * 5 + phases[i]);
}
else if (type === 'red') {
  brightness = 0.85 + 0.25 * Math.sin(time * 4 + phases[i]);
}
else {
  brightness = 0.78 + 0.22 * Math.sin(time * 3 + phases[i]);
}
          colors[i*3]   = baseColor.r * brightness;
          colors[i*3+1] = baseColor.g * brightness;
          colors[i*3+2] = baseColor.b * brightness;
        }
        group.geometry.attributes.color.needsUpdate = true;
        group.geometry.attributes.size.needsUpdate = true;
        } else if (targetState === 'HEART') {
        group.rotation.y = 0;
        const beatScale = 1 + Math.abs(Math.sin(time * 3)) * 0.15;
        group.scale.set(beatScale, beatScale, beatScale);
        for(let i=0; i<count; i++) {
          colors[i*3] = baseColor.r; colors[i*3+1] = baseColor.g; colors[i*3+2] = baseColor.b;
          if (i % 3 === 0) sizes[i] = baseSize;
          else sizes[i] = 0;
        }
        group.geometry.attributes.color.needsUpdate = true;
        group.geometry.attributes.size.needsUpdate = true;
        } else {
        group.scale.set(1,1,1);
        group.rotation.y += (handRotY - group.rotation.y) * 0.1;
        for(let i=0; i<count; i++) {
          sizes[i] = (type === 'gift') ? baseSize : (baseSize * (0.92 + 0.12 * Math.sin(time*2.5 + phases[i])));
let brightness;
if (type === 'gold') {
  brightness = 0.85 + 0.25 * Math.sin(time * 6 + phases[i]);
}
else if (type === 'red') {
  brightness = 0.80 + 0.22 * Math.sin(time * 5 + phases[i]);
}
else {
  brightness = 0.75 + 0.20 * Math.sin(time * 4 + phases[i]);
}
          colors[i*3]   = baseColor.r * brightness;
          colors[i*3+1] = baseColor.g * brightness;
          colors[i*3+2] = baseColor.b * brightness;
        }
        group.geometry.attributes.size.needsUpdate = true;
        group.geometry.attributes.color.needsUpdate = true;
      }
    }
    function updateHeartStar(time) {
      if (!heartStarMesh) return;
      const posAttr = heartStarMesh.geometry.attributes.position;
      const pos = posAttr.array;
      const base = heartStarMesh.geometry.userData.basePositions;
      const dissolve = heartStarMesh.geometry.userData.dissolveTargets;
      const wantVisible = (state === 'TREE');
      const targetFade = wantVisible ? 1.0 : 0.0;
      heartStarMesh.geometry.userData.fade += (targetFade - heartStarMesh.geometry.userData.fade) * 0.10;
      const fade = heartStarMesh.geometry.userData.fade;
      const lerpToBase = wantVisible ? 0.10 : 0.0;
      const lerpToDiss = wantVisible ? 0.0 : 0.12;
      for (let i = 0; i < pos.length; i += 3) {
        if (wantVisible) {
          pos[i]   += (base[i]   - pos[i])   * lerpToBase;
          pos[i+1] += (base[i+1] - pos[i+1]) * lerpToBase;
          pos[i+2] += (base[i+2] - pos[i+2]) * lerpToBase;
        } else {
          pos[i]   += (dissolve[i]   - pos[i])   * lerpToDiss;
          pos[i+1] += (dissolve[i+1] - pos[i+1]) * lerpToDiss;
          pos[i+2] += (dissolve[i+2] - pos[i+2]) * lerpToDiss;
        }
      }
      posAttr.needsUpdate = true;
    heartStarMesh.rotation.set(0, 0, 0);
    heartStarMesh.scale.set(1, 1, 1);
    }
    function updateAuraSpiral(time) {
      if (!auraSpiralMesh) return;
      const wantVisible = (state === 'TREE');
      const targetOpacity = wantVisible ? 0.92 : 0.0;
      auraSpiralMesh.material.opacity += (targetOpacity - auraSpiralMesh.material.opacity) * 0.12;
      auraSpiralMesh.visible = (auraSpiralMesh.material.opacity > 0.02);
      if (auraSpiralMesh.visible) {
        auraSpiralMesh.rotation.y -= 0.010;
        const cols = auraSpiralMesh.geometry.attributes.color.array;
        const phases = auraSpiralMesh.geometry.userData.phases;
        for (let i = 0; i < phases.length; i++) {
          const b = 0.65 + 0.35 * (0.5 + 0.5 * Math.sin(time*8.0 + phases[i]));
          cols[i*3]   = b;
          cols[i*3+1] = b;
          cols[i*3+2] = b;
        }
        auraSpiralMesh.geometry.attributes.color.needsUpdate = true;
      }
    }
    function updateGround(time) {
      const hide = (state === 'EXPLODE' || state === 'PHOTO');
      const targetOpacityA = hide ? 0.0 : 0.98;
      const targetOpacityB = hide ? 0.0 : 0.28;
      if (groundMesh) {
        groundMesh.material.opacity += (targetOpacityA - groundMesh.material.opacity) * 0.10;
        const cols = groundMesh.geometry.attributes.color.array;
        const phases = groundMesh.geometry.userData.phases;
        const base = groundMesh.geometry.userData.baseColor;
        for (let i = 0; i < phases.length; i++) {
          const b = 0.52 + 0.48 * (0.5 + 0.5 * Math.sin(time*3.0 + phases[i]));
          cols[i*3]   = base.r * b;
          cols[i*3+1] = base.g * b;
          cols[i*3+2] = base.b * b;
        }
        groundMesh.geometry.attributes.color.needsUpdate = true;
      }
      if (groundMeshSoft) {
        groundMeshSoft.material.opacity += (targetOpacityB - groundMeshSoft.material.opacity) * 0.10;
      }
    }
    function animate() {
      requestAnimationFrame(animate);
      const time = Date.now() * 0.001;
      const speed = 0.08;
      const handRotY = (handX - 0.5) * 4.0;
      const wantTreeVisible = (state !== 'PHOTO');
      const targetTreeFade = wantTreeVisible ? 1.0 : 0.0;
      treeFade += (targetTreeFade - treeFade) * 0.10;
      if (groupGold && groupGold.material) groupGold.material.opacity = treeFade;
      if (groupRed  && groupRed.material)  groupRed.material.opacity  = treeFade;
      if (groupGift && groupGift.material) groupGift.material.opacity = treeFade;
      updateParticleGroup(groupGold, 'gold', state, speed, handRotY, time);
      updateParticleGroup(groupRed,  'red',  state, speed, handRotY, time);
      updateParticleGroup(groupGift, 'gift', state, speed, handRotY, time);
      photoMeshes.forEach((mesh, i) => {
        if(!mesh.material.map && photoTextures[i]) {
          mesh.material.map = photoTextures[i]; mesh.material.needsUpdate = true;
        }
      });
      updateHeartStar(time);
      updateAuraSpiral(time);
      if (snowMesh) {
        const pos = snowMesh.geometry.attributes.position.array;
        const spd = snowMesh.geometry.userData.speeds;
        for (let i = 0; i < spd.length; i++) {
          const idxY = i*3 + 1;
          pos[idxY] -= spd[i];
          pos[i*3]   += Math.sin(time*0.9 + i) * 0.0022;
          pos[i*3+2] += Math.cos(time*0.9 + i) * 0.0022;
          if (pos[idxY] < -CONFIG.treeHeight/2 - 10) {
            pos[idxY] = 120 + Math.random() * 30;
          }
        }
        snowMesh.geometry.attributes.position.needsUpdate = true;
        snowMesh.material.opacity = 0.78 + 0.22 * Math.sin(time * 2.0);
      }
      updateGround(time);
      if (state === 'TREE') {
        titleMesh.visible = true; loveMesh.visible = false;
        titleMesh.scale.lerp(new THREE.Vector3(1,1,1), 0.1);
        photoMeshes.forEach(m => { m.scale.lerp(new THREE.Vector3(0,0,0), 0.1); m.visible = false; });
      } else if (state === 'HEART') {
        titleMesh.visible = false; loveMesh.visible = true;
        photoMeshes.forEach(m => { m.visible = false; });
        const s = 1 + Math.abs(Math.sin(time*3))*0.1;
        loveMesh.scale.set(s,s,1);
      } else if (state === 'EXPLODE') {
        titleMesh.visible = false; loveMesh.visible = false;
        const baseAngle = groupGold.rotation.y;
        const angleStep = (Math.PI * 2) / 5;
        let bestIdx = 0; let maxZ = -999;
        photoMeshes.forEach((mesh, i) => {
          mesh.visible = true;
          const angle = baseAngle + i * angleStep;
          const x = Math.sin(angle) * CONFIG.photoOrbitRadius;
          const z = Math.cos(angle) * CONFIG.photoOrbitRadius;
          const y = Math.sin(time + i) * 3;
          mesh.position.lerp(new THREE.Vector3(x, y, z), 0.1);
          mesh.lookAt(camera.position);
          if (z > maxZ) { maxZ = z; bestIdx = i; }
          if (z > 5) {
            const ds = 1.0 + (z/CONFIG.photoOrbitRadius)*0.8;
            mesh.scale.lerp(new THREE.Vector3(ds, ds, ds), 0.1);
          } else {
            mesh.scale.lerp(new THREE.Vector3(0.6, 0.6, 0.6), 0.1);
          }
        });
        selectedIndex = bestIdx;
      } else if (state === 'PHOTO') {
        loveMesh.visible = false;
        photoMeshes.forEach((mesh, i) => {
          if (i === selectedIndex) {
            mesh.position.lerp(new THREE.Vector3(0, 0, 60), 0.1);
            mesh.scale.lerp(new THREE.Vector3(5, 5, 5), 0.1);
            mesh.lookAt(camera.position); mesh.rotation.z = 0;
          } else {
            mesh.scale.lerp(new THREE.Vector3(0,0,0), 0.1);
          }
        });
      }
      renderer.render(scene, camera);
    }
    const previewCanvas = document.getElementById('camera-preview');
    previewCanvas.width = 120;
    previewCanvas.height = 90;
    const pctx = previewCanvas.getContext('2d');
    const HAND_CONNECTIONS = [
      [0,1],[1,2],[2,3],[3,4],
      [0,5],[5,6],[6,7],[7,8],
      [5,9],[9,10],[10,11],[11,12],
      [9,13],[13,14],[14,15],[15,16],
      [13,17],[17,18],[18,19],[19,20],
      [0,17]
    ];
    function drawHandSkeleton(ctx, lm) {
      ctx.strokeStyle = '#FF69B4';
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.95;
      HAND_CONNECTIONS.forEach(([a,b]) => {
        ctx.beginPath();
        ctx.moveTo(lm[a].x * previewCanvas.width, lm[a].y * previewCanvas.height);
        ctx.lineTo(lm[b].x * previewCanvas.width, lm[b].y * previewCanvas.height);
        ctx.stroke();
      });
      ctx.fillStyle = '#FFD1EA';
      lm.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x * previewCanvas.width, p.y * previewCanvas.height, 2.2, 0, Math.PI*2);
        ctx.fill();
      });
      ctx.globalAlpha = 1.0;
    }
    function startSystem() {
      init3D();
      const video = document.getElementsByClassName('input_video')[0];
      const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
      hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
      hands.onResults(results => {
        pctx.clearRect(0,0,previewCanvas.width, previewCanvas.height);
        pctx.fillStyle = 'black';
        pctx.fillRect(0,0,previewCanvas.width, previewCanvas.height);
        if (results.multiHandLandmarks && results.multiHandLandmarks.length) {
          results.multiHandLandmarks.forEach(lm => drawHandSkeleton(pctx, lm));
        }
        if (results.multiHandLandmarks && results.multiHandLandmarks.length === 2) {
          const h1 = results.multiHandLandmarks[0];
          const h2 = results.multiHandLandmarks[1];
          const distIndex = Math.hypot(h1[8].x - h2[8].x, h1[8].y - h2[8].y);
          const distThumb = Math.hypot(h1[4].x - h2[4].x, h1[4].y - h2[4].y);
          const distWrist = Math.hypot(h1[0].x - h2[0].x, h1[0].y - h2[0].y);
          const looksLikeHeart = (distIndex < 0.09 && distThumb < 0.09 && distWrist > 0.18 && distWrist < 0.55);
          if (looksLikeHeart) heartGestureFrames++;
          else heartGestureFrames = Math.max(0, heartGestureFrames - 2);
          if (heartGestureFrames >= 12) {
            state = 'HEART';
            return;
          }
        } else {
          heartGestureFrames = 0;
        }
        if(results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
          const lm = results.multiHandLandmarks[0];
          handX = lm[9].x;
          const tips = [8,12,16,20];
          const wrist = lm[0];
          let openDist = 0;
          tips.forEach(i => openDist += Math.hypot(lm[i].x-wrist.x, lm[i].y-wrist.y));
          const avgDist = openDist / 4;
          const pinchDist = Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y);
          if (avgDist < 0.25) {
            state = 'TREE';
          } else if (pinchDist < 0.05) {
            state = 'PHOTO';
          } else {
            state = 'EXPLODE';
          }
        } else {
          state = 'TREE';
        }
      });
      const cameraUtils = new Camera(video, {
        onFrame: async () => { await hands.send({image: video}); },
        width: 320, height: 240
      });
      cameraUtils.start();
    }
    window.addEventListener('resize', () => {
      if(camera) {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    });
    window.addEventListener('load', startSystem);
  </script>
</body>
</html>
